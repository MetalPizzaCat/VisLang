[gd_scene load_steps=29 format=3 uid="uid://wafw1x7x4s1b"]

[ext_resource type="Script" path="res://Script/MainScene/FunctionSignatureManager.cs" id="1_0ioe4"]
[ext_resource type="Resource" uid="uid://migjfmdltwbc" path="res://Functions/Func_Add_F.tres" id="2_wet2g"]
[ext_resource type="Resource" uid="uid://dpkha8n5rkowh" path="res://Functions/Func_Print.tres" id="3_grib6"]
[ext_resource type="Resource" uid="uid://l1eetdpg8ut5" path="res://Functions/Func_Array_Append.tres" id="4_mdhqx"]
[ext_resource type="Resource" uid="uid://dpc05ors8lkbo" path="res://Functions/Func_Array_SetElem.tres" id="5_0kae3"]
[ext_resource type="Resource" uid="uid://b4ca7uc8mn75i" path="res://Functions/Func_Array_GetElem.tres" id="6_d6cee"]
[ext_resource type="Resource" path="res://Assets/DefaultCodeTheme.tres" id="8_s3pu7"]
[ext_resource type="Texture2D" uid="uid://bgqiirjom5845" path="res://Assets/data_connector.svg" id="10_0vy0f"]
[ext_resource type="Texture2D" uid="uid://cwgvbucmd5jax" path="res://Assets/UI/warning.svg" id="11_vs7wd"]
[ext_resource type="Texture2D" uid="uid://h8kent0a76vm" path="res://Assets/data_connector_array.svg" id="12_vuxjd"]
[ext_resource type="Texture2D" uid="uid://csuobr08jgr0j" path="res://Assets/node_basic_style_exec.svg" id="13_8taiv"]
[ext_resource type="Texture2D" uid="uid://c7xrcd3acougr" path="res://Assets/node_basic_style_exec_base.svg" id="14_nfxda"]
[ext_resource type="Texture2D" uid="uid://d0vsau6vks6tu" path="res://icon.svg" id="15_lonmn"]

[sub_resource type="CSharpScript" id="CSharpScript_75yof"]
script/source = "using Godot;
using System;
using System.Collections.Generic;


public partial class EditorVisNode : Node2D
{
    public delegate void ExecNodeSelectedEventHandler(ExecInput node);
    public event ExecNodeSelectedEventHandler? ExecNodeSelected;

    public delegate void DeleteRequestedEventHandler(EditorVisNode node);
    public event DeleteRequestedEventHandler? DeleteRequested;

    public delegate void GrabbedEventHandler(EditorVisNode node);
    /// <summary>
    /// Invoked when user selects a node by pressing on it 
    /// </summary>
    public event GrabbedEventHandler? Grabbed;

    public delegate void ReleasedEventHandler(EditorVisNode node);
    /// <summary>
    /// Invoked when user stops pressing on a node
    /// </summary>
    public event ReleasedEventHandler? Released;

    public delegate void InputNodeSelectedEventHandler(NodeInput input);
    public event InputNodeSelectedEventHandler? InputNodeSelected;

    private FunctionInfo? _info = null;
    public FunctionInfo? FunctionInfo
    {
        get => _info;
        set
        {
            if (MainButton != null && value != null)
            {
                MainButton.TooltipText = value.FunctionDescription;
            }
            _info = value;
        }
    }

    [Export]
    public CodeColorTheme? CodeTheme { get; set; }
    [Export]
    public float InputNodeOffsetStep { get; set; } = 32f;

    [Export]
    public Button? MainButton { get; set; }
    [Export]
    public PackedScene? NodeInputPrefab { get; set; } = null;

    [Export]
    public Node2D NodeInputAnchor { get; set; }

    [Export]
    public NodeInput NodeOutput { get; set; }

    [Export]
    public Label? NodeNameLabel { get; set; }
    [Export]
    public PopupMenu? ContextMenu { get; set; }

    [ExportGroup(\"Exec\")]
    [Export]
    public ExecInput? InputExecNode { get; set; }
    [Export]
    public ExecInput? OutputExecNode { get; set; }
    [ExportGroup(\"User debug\")]
    [Export]
    public Sprite2D? ExecutionDebugIcon { get; set; }

    public List<NodeInput> Inputs { get; set; } = new List<NodeInput>();
    /// <summary>
    /// All of the inputs that had connections before node was recreated 
    /// </summary>
    protected List<NodeInput> InvalidInputs { get; set; } = new();


    private bool _isCurrentlyExecuted = false;
    public bool IsCurrentlyExecuted
    {
        get => _isCurrentlyExecuted;
        set
        {
            _isCurrentlyExecuted = value;
            if (ExecutionDebugIcon != null)
            {
                ExecutionDebugIcon.Visible = value;
            }
        }
    }
    public override void _Ready()
    {
        if (FunctionInfo != null)
        {
            GenerateFunction(FunctionInfo);
        }
        if (InputExecNode != null)
        {
            InputExecNode.Selected += InputExecSelected;
            InputExecNode.OwningNode = this;
        }
        if (OutputExecNode != null)
        {
            OutputExecNode.Selected += OutputExecSelected;
            OutputExecNode.OwningNode = this;
        }
        NodeOutput.Selected += (NodeInput input) => { InputNodeSelected?.Invoke(input); };
        NodeOutput.OwningNode = this;
    }

    /// <summary>
    /// Call this when node is added to the canvas for the node to perform all of the additional event connections and node adjustments
    /// </summary>
    /// <param name=\"canvas\">Main canvas</param>
    public virtual void InitOnCanvas(MainScene canvas)
    {
        // grab any additional events here
    }

    protected NodeInput? CreateInput(FunctionInputInfo argument)
    {
        NodeInput? input = NodeInputPrefab?.InstantiateOrNull<NodeInput>();
        if (input == null)
        {
            GD.PrintErr(\"Unable to create inputs from prefab\");
            return null;
        }
        input.OwningNode = this;
        input.InputName = argument.InputName;
        input.TypeMatchingPermissions = argument.TypeMatchingPermissions;
        input.IsArrayTypeDependent = argument.IsArrayTypeDependent;
        input.InputType = argument.InputType;
        input.ArrayDataType = argument.HasArrayType ? argument.ArrayDataType : null;
        input.Selected += (NodeInput input) => { InputNodeSelected?.Invoke(input); };

        return input;
    }

    /// <summary>
    /// Generates and adds new inputs to the inputs array. Previous inputs are not erased
    /// </summary>
    /// <param name=\"inputNodeVisualOffset\">Start offset for the nodes</param>
    protected virtual void GenerateInputs(float inputNodeVisualOffset, FunctionInfo info)
    {
        float currentInputOffset = inputNodeVisualOffset;
        foreach (FunctionInputInfo argument in info.Inputs)
        {
            NodeInput? input = CreateInput(argument);
            if (input == null)
            {
                GD.PrintErr(\"Unable to create inputs from prefab\");
                return;
            }
            Inputs.Add(input);
            NodeInputAnchor.AddChild(input);
            input.Position = new Vector2(0, currentInputOffset);
            currentInputOffset += InputNodeOffsetStep;
        }
    }

    protected virtual void GenerateOutput(FunctionInfo info)
    {
        NodeOutput.Visible = true;
        NodeOutput.InputType = info.OutputType ?? VisLang.ValueType.Bool;
        NodeOutput.ArrayDataType = info.HasOutputTypeArrayType ? info.OutputArrayType : null;
        NodeOutput.TypeMatchingPermissions = (info.IsOutputTypeKnown ?? false) ? FunctionInputInfo.TypePermissions.SameTypeOnly : FunctionInputInfo.TypePermissions.AllowAny;
    }

    public void GenerateFunction(FunctionInfo info)
    {
        FunctionInfo = info;
        if (NodeInputPrefab == null)
        {
            throw new NullReferenceException(\"Unable to create node from description because input node was not provided\");
        }

        // since some nodes might have connections and since i don't want to just delete the connections 
        // as that would create some confusion(for example if user doesn't not notice connections disappearing)
        // to combat that we will keep nodes that have connections intact but move them to the bottom of the list
        // ***
        // there is a bit of an issue here for when user might change type and then change it back since in this case 
        // the connection will still be marked as invalid
        foreach (NodeInput input in Inputs)
        {
            if (input.IsInputConnected)
            {
                InvalidInputs.Add(input);
                // this way once user tries to reset connection node will disappear, preventing further confusion
                input.ConnectionDestroyed += DestroyInvalidNode;
            }
            else
            {
                input.QueueFree();
            }
        }
        Inputs.Clear();

        GenerateInputs(0f, info);

        float offset = Inputs.Count * InputNodeOffsetStep + InputNodeOffsetStep;
        foreach (NodeInput input in InvalidInputs)
        {
            input.Position = new Vector2(0, offset);
            offset += InputNodeOffsetStep;
            input.Valid = false;
        }

        if (info.HasOutput)
        {
            GenerateOutput(info);
        }
        if (NodeNameLabel != null)
        {
            NodeNameLabel.Text = info.FunctionName;
        }
    }

    private void DestroyInvalidNode(NodeInput input)
    {
        InvalidInputs.Remove(input);
        input.Destroy();
    }

    protected virtual void ApplyAdditionalDataToNode<NodeType>(NodeType node) where NodeType : VisLang.VisNode
    {
        // implement in this child to set whatever extra data you want :3
        // for example SetterNode should implement to have variable name setting here
    }

    public NodeType? CreateNode<NodeType>(VisLang.VisSystem? interpreter) where NodeType : VisLang.VisNode
    {
        if (FunctionInfo == null)
        {
            throw new MissingFunctionInfoException(\"Attempted to create a function but FunctionInfo is null\");
        }
        NodeType? node = (NodeType?)Activator.CreateInstance(\"VisLang\", FunctionInfo.NodeType)?.Unwrap();
        if (node == null)
        {
            return null;
        }
        node.Interpreter = interpreter;
        ApplyAdditionalDataToNode(node);
        return node;
    }

    public void InputExecSelected(ExecInput exec)
    {
        ExecNodeSelected?.Invoke(exec);
    }

    public void OutputExecSelected(ExecInput exec)
    {
        ExecNodeSelected?.Invoke(exec);
    }

    private void GrabNode()
    {
        Grabbed?.Invoke(this);
    }

    private void ReleaseNode()
    {
        Released?.Invoke(this);
    }

    protected virtual void ContextMenuOptionSelected(long option)
    {
        if (option == 0)
        {
            DeleteRequested?.Invoke(this);
        }
    }

    protected void ButtonGuiInput(InputEvent @event)
    {
        if (@event is InputEventMouseButton btn && btn.Pressed && btn.ButtonIndex == MouseButton.Right && ContextMenu != null)
        {
            ContextMenu.Position = new Vector2I((int)btn.Position.X, (int)btn.Position.Y);
            ContextMenu?.Popup();
        }
    }
}
"

[sub_resource type="CSharpScript" id="CSharpScript_fh1wk"]
script/source = "using Godot;
using System;

/// <summary>
/// Object that allows user to either input values by hand or connect to other inputs
/// </summary>
public partial class NodeInput : Node2D
{
    public delegate void DestroyedEventHandler(NodeInput sender);
    public delegate void ConnectionCreatedEventHandler(NodeInput sender, NodeInput other);
    public delegate void ConnectionDestroyedEventHandler(NodeInput sender);
    public event ConnectionCreatedEventHandler? ConnectionCreated;
    public event ConnectionDestroyedEventHandler? ConnectionDestroyed;
    /// <summary>
    /// Called when node is being destroyed
    /// </summary>
    public event DestroyedEventHandler? Destroyed;

    public delegate void SelectedEventHandler(NodeInput input);
    public event SelectedEventHandler? Selected;

    [Export]
    public CodeColorTheme? Theme { get; set; }
    [Export]
    public Label InputNameLabel { get; set; }

    [Export]
    public bool IsInput { get; set; } = true;
    [Export]
    public Sprite2D DefaultIcon { get; set; }
    [Export]
    public Sprite2D ArrayIcon { get; set; }
    [Export]
    public Sprite2D ErrorIcon { get; set; }


    [Export]
    public FunctionInputInfo.TypePermissions TypeMatchingPermissions { get; set; } = FunctionInputInfo.TypePermissions.SameTypeOnly;

    [ExportGroup(\"Input fields\")]
    [Export]
    public LineEdit StringInput { get; set; }
    [Export]
    public SpinBox NumberInput { get; set; }
    [Export]
    public CheckBox BoolInput { get; set; }
    [Export]
    public SpinBox IntInput { get; set; }

    public EditorVisNode? OwningNode { get; set; } = null;

    private NodeInput? _connection = null;

    private bool _valid = true;

    public bool Valid
    {
        get => _valid;
        set
        {
            _valid = value;
            ErrorIcon.Visible = !value;
        }
    }


    /// <summary>
    /// Other side of the connection node
    /// </summary>
    public NodeInput? Connection
    {
        get => _connection;
        set
        {
            NodeInput? old = _connection;
            _connection = value;
            // if was and now is not means connection destroyed 
            if (old != null && _connection == null)
            {
                ConnectionDestroyed?.Invoke(this);
            }
            // if was not and now is means connection created
            if (old == null && _connection != null)
            {
                ConnectionCreated?.Invoke(this, _connection);
            }
            UpdateInputsVisuals();
        }
    }

    public bool IsManualInputVisible => !IsInputConnected && IsInput && !IsArray && Valid;

    public bool IsInputConnected => Connection != null;

    public string InputName
    {
        get => InputNameLabel.Text;
        set => InputNameLabel.Text = value;
    }

    private VisLang.ValueType _inputType = VisLang.ValueType.Bool;
    private VisLang.ValueType? _arrayDataType = null;
    /// <summary>
    /// If true given input should change it's type based on parent node array type
    /// </summary>
    [Export]
    public bool IsArrayTypeDependent { get; set; } = false;

    public VisLang.ValueType InputType
    {
        get => _inputType;
        set
        {
            _inputType = value;
            UpdateInputsVisuals();
        }
    }

    /// <summary>
    /// Data type of the typed array. Only applies if InputType is Array
    /// </summary>
    /// <value></value>
    public VisLang.ValueType? ArrayDataType
    {
        get => _arrayDataType;
        set
        {
            _arrayDataType = value;
            UpdateInputsVisuals();
        }
    }

    /// <summary>
    /// True if base type of the input is an array
    /// </summary>
    public bool IsArray => InputType == VisLang.ValueType.Array;


    /// <summary>
    /// Get current value stored in the input. Resulting value will depend on InputType
    /// </summary>
    /// <value></value>
    public object Data
    {
        get
        {
            switch (_inputType)
            {
                case VisLang.ValueType.Bool:
                    return BoolInput.ButtonPressed;
                case VisLang.ValueType.Float:
                    // using float because i said so >:(
                    return (float)NumberInput.Value;
                case VisLang.ValueType.String:
                    return StringInput.Text;
                case VisLang.ValueType.Integer:
                    // godot uses double for spin box but int can't be double can it?
                    return (int)IntInput.Value;
            }
            return 0;
        }
    }

    /// <summary>
    /// Updates visibility and colors for the input elements and type icon
    /// </summary>
    private void UpdateInputsVisuals()
    {
        // inputs are not visible if it's not an input, but also invisible if it's an array since we don't provide a way to edit arrays via editor
        // because that would be too annoying to add 
        StringInput.Visible = InputType == VisLang.ValueType.String && IsManualInputVisible;
        NumberInput.Visible = InputType == VisLang.ValueType.Float && IsManualInputVisible;
        BoolInput.Visible = InputType == VisLang.ValueType.Bool && IsManualInputVisible;
        IntInput.Visible = InputType == VisLang.ValueType.Integer && IsManualInputVisible;
        if (Theme != null)
        {
            if (IsArray)
            {
                ArrayIcon.SelfModulate = TypeMatchingPermissions == FunctionInputInfo.TypePermissions.AllowAny ? Theme.AnyColor : Theme.GetColorForType(ArrayDataType ?? VisLang.ValueType.Array);
                ArrayIcon.Visible = true;
                DefaultIcon.Visible = false;
            }
            else
            {
                DefaultIcon.SelfModulate = TypeMatchingPermissions == FunctionInputInfo.TypePermissions.AllowAny ? Theme.AnyColor : Theme.GetColorForType(InputType);
                DefaultIcon.Visible = true;
                ArrayIcon.Visible = false;
            }
        }
        ErrorIcon.Visible = !Valid;
    }

    private void Pressed()
    {
        Selected?.Invoke(this);
    }

    /// <summary>
    /// Checks if connection to the given node is possible
    /// </summary>
    /// <param name=\"other\">Node to check connections against</param>
    /// <returns>True if connection is valid</returns>
    public bool IsValidTypeConnection(NodeInput other)
    {
        bool validArrayConnection = true;
        // if both are arrays we have to check if they are compatible based on the stored type
        if (other.IsArray == IsArray)
        {
            // valid is 
            // both are arrays but accept any *
            // destination accepts any 
            // both have matching types *
            // * <- can be check by comparison of the nullable since it will success if either both null or both are not and have same data
            validArrayConnection = ArrayDataType == null || ArrayDataType == other.ArrayDataType;
        }
        // check if types are known at design time and if they are ensure that they match
        // if type can not be known at design time we allow the connection and make runtime deal with it
        // if input does not care what type is passed into we also allow the connection and make it runtime's job to deal with errors  
        return (other.InputType == InputType && validArrayConnection) ||
         (TypeMatchingPermissions == FunctionInputInfo.TypePermissions.AllowAny || other.TypeMatchingPermissions == FunctionInputInfo.TypePermissions.AllowAny);
    }

    /// <summary>
    /// Can this node connect to other node. Check should be called on destination and have source as the argument(call from right pass left)
    /// </summary>
    public bool CanConnect(NodeInput other)
    {
        // output can have as many connections as it wants, since it doesn't store any information about them
        bool connected = IsInput ? (Connection != null) : false;
        return Valid && !(connected || other.OwningNode == OwningNode || other.IsInput == IsInput || !IsValidTypeConnection(other));
    }

    /// <summary>
    /// Destroy this input and notify all listeners that it was destroyed
    /// </summary>
    public void Destroy()
    {
        Destroyed?.Invoke(this);
        QueueFree();
    }
}
"

[sub_resource type="PackedScene" id="PackedScene_kk38h"]
_bundled = {
"conn_count": 1,
"conns": PackedInt32Array(1073741835, 1073741834, 87, 86, 2, 0, 0),
"editable_instances": [],
"names": PackedStringArray("NodeInput", "Node2D", "script", "Theme", "InputNameLabel", "DefaultIcon", "ArrayIcon", "ErrorIcon", "StringInput", "NumberInput", "BoolInput", "IntInput", "Button", "Button", "modulate", "offset_left", "offset_top", "offset_right", "offset_bottom", "IconDefault", "Sprite2D", "scale", "texture", "IconInvalidConnection", "Sprite2D", "position", "scale", "texture", "IconArray", "Sprite2D", "visible", "position", "scale", "texture", "InputName", "Label", "offset_left", "offset_top", "offset_right", "offset_bottom", "text", "ManualInputControls", "Control", "layout_mode", "anchors_preset", "offset_right", "offset_bottom", "StringInput", "LineEdit", "visible", "layout_mode", "offset_left", "offset_top", "offset_right", "offset_bottom", "NumberInput", "SpinBox", "visible", "layout_mode", "offset_left", "offset_top", "offset_right", "offset_bottom", "step", "allow_greater", "allow_lesser", "custom_arrow_step", "IntInput", "SpinBox", "visible", "layout_mode", "offset_left", "offset_top", "offset_right", "offset_bottom", "allow_greater", "allow_lesser", "custom_arrow_step", "BoolInput", "CheckBox", "visible", "layout_mode", "offset_left", "offset_top", "offset_right", "offset_bottom", "Pressed", "pressed"),
"node_count": 11,
"node_paths": [NodePath("."), NodePath("."), NodePath("."), NodePath("."), NodePath("."), NodePath("."), NodePath("./ManualInputControls"), NodePath("./ManualInputControls"), NodePath("./ManualInputControls"), NodePath("./ManualInputControls"), NodePath("."), NodePath("Button")],
"nodes": PackedInt32Array(-1, -1, 1, 0, -1, 10, 2, 0, 3, 1, 1073741828, 2, 1073741829, 3, 1073741830, 4, 1073741831, 5, 1073741832, 6, 1073741833, 7, 1073741834, 8, 1073741835, 9, 0, 1073741824, 0, 13, 12, -1, 5, 14, 10, 15, 11, 16, 12, 17, 13, 18, 14, 0, 1073741825, 0, 20, 19, -1, 2, 21, 15, 22, 16, 0, 1073741826, 0, 24, 23, -1, 3, 25, 17, 26, 18, 27, 19, 0, 1073741827, 0, 29, 28, -1, 4, 30, 20, 31, 21, 32, 22, 33, 23, 0, 1073741828, 0, 35, 34, -1, 5, 36, 24, 37, 25, 38, 26, 39, 27, 40, 28, 0, 1073741829, 0, 42, 41, -1, 4, 43, 29, 44, 30, 45, 31, 46, 32, 0, 1073741830, 0, 48, 47, -1, 6, 49, 33, 50, 34, 51, 35, 52, 36, 53, 37, 54, 38, 0, 1073741831, 0, 56, 55, -1, 10, 57, 39, 58, 40, 59, 41, 60, 42, 61, 43, 62, 44, 63, 45, 64, 46, 65, 47, 66, 48, 0, 1073741832, 0, 68, 67, -1, 9, 69, 49, 70, 50, 71, 51, 72, 52, 73, 53, 74, 54, 75, 55, 76, 56, 77, 57, 0, 1073741833, 0, 79, 78, -1, 6, 80, 58, 81, 59, 82, 60, 83, 61, 84, 62, 85, 63, 0),
"variants": [SubResource("CSharpScript_fh1wk"), ExtResource("8_s3pu7"), NodePath("InputName"), NodePath("IconDefault"), NodePath("IconArray"), NodePath("IconInvalidConnection"), NodePath("ManualInputControls/StringInput"), NodePath("ManualInputControls/NumberInput"), NodePath("ManualInputControls/BoolInput"), NodePath("ManualInputControls/IntInput"), Color(0.952941, 1, 0.976471, 1), -16.0, -16.0, 16.0, 16.0, Vector2(0.360417, 0.360417), ExtResource("10_0vy0f"), Vector2(-1.07288e-06, 4.76837e-07), Vector2(0.470588, 0.561404), ExtResource("11_vs7wd"), false, Vector2(-4.76837e-07, -4.76837e-07), Vector2(0.580208, 0.580208), ExtResource("12_vuxjd"), -128.0, -16.0, -34.0, 10.0, "NAMENAME", 3, 0, 40.0, 40.0, false, 0, 32.0, -16.0, 128.0, 15.0, false, 0, 32.0, -16.0, 128.0, 15.0, 0.0, true, true, 0.1, false, 0, 32.0, -16.0, 128.0, 15.0, true, true, 0.1, false, 0, 32.0, -8.0, 56.0, 16.0],
"version": 3
}

[sub_resource type="LabelSettings" id="LabelSettings_qu6ij"]
font_color = Color(0, 0, 0, 1)

[sub_resource type="PackedScene" id="PackedScene_agsmv"]
_bundled = {
"conn_count": 4,
"conns": PackedInt32Array(1073741834, 1073741833, 62, 61, 2, 0, 0, 1073741836, 1073741835, 64, 63, 2, 0, 0, 1073741838, 1073741837, 66, 65, 2, 0, 0, 1073741840, 1073741839, 68, 67, 2, 0, 0),
"editable_instances": [],
"names": PackedStringArray("VisNode", "Node2D", "script", "CodeTheme", "MainButton", "NodeInputPrefab", "NodeInputAnchor", "NodeOutput", "NodeNameLabel", "ContextMenu", "ExecutionDebugIcon", "Button", "Button", "offset_left", "offset_top", "offset_right", "offset_bottom", "NodeBasicStyleExec", "Sprite2D", "modulate", "texture_filter", "position", "scale", "texture", "NodeBasicStyleExecBase", "Sprite2D", "position", "scale", "texture", "Label", "Label", "offset_left", "offset_top", "offset_right", "offset_bottom", "text", "label_settings", "horizontal_alignment", "Icon", "Sprite2D", "visible", "texture", "NodeInputAnchor", "Node2D", "position", "NodeDataOutput", "visible", "position", "IsInput", "ExecutionStepDisplayIcon", "Sprite2D", "visible", "modulate", "position", "rotation", "texture", "PopupMenu", "PopupMenu", "item_count", "item_0/text", "item_0/id", "GrabNode", "button_down", "ReleaseNode", "button_up", "ButtonGuiInput", "gui_input", "ContextMenuOptionSelected", "index_pressed"),
"node_count": 10,
"node_paths": [NodePath("."), NodePath("."), NodePath("."), NodePath("."), NodePath("."), NodePath("."), NodePath("."), NodePath("."), NodePath("."), NodePath("."), NodePath("Button"), NodePath("."), NodePath("Button"), NodePath("."), NodePath("Button"), NodePath("."), NodePath("PopupMenu")],
"nodes": PackedInt32Array(-1, -1, 1, 0, -1, 9, 2, 0, 3, 1, 1073741828, 2, 5, 3, 1073741830, 4, 1073741831, 5, 1073741832, 6, 1073741833, 7, 1073741834, 8, 0, 1073741824, 0, 12, 11, -1, 4, 13, 9, 14, 10, 15, 11, 16, 12, 0, 1073741825, 0, 18, 17, -1, 5, 19, 13, 20, 14, 21, 15, 22, 16, 23, 17, 0, 1073741826, 0, 25, 24, -1, 3, 26, 18, 27, 19, 28, 20, 0, 1073741827, 0, 30, 29, -1, 7, 31, 21, 32, 22, 33, 23, 34, 24, 35, 25, 36, 26, 37, 27, 0, 1073741828, 0, 39, 38, -1, 2, 40, 28, 41, 29, 0, 1073741829, 0, 43, 42, -1, 1, 44, 30, 0, 1073741830, 0, 2147483647, 45, 31, 3, 46, 32, 47, 33, 48, 34, 0, 1073741831, 0, 50, 49, -1, 5, 51, 35, 52, 36, 53, 37, 54, 38, 55, 39, 0, 1073741832, 0, 57, 56, -1, 3, 58, 40, 59, 41, 60, 42, 0),
"variants": [SubResource("CSharpScript_75yof"), ExtResource("8_s3pu7"), NodePath("Button"), SubResource("PackedScene_kk38h"), NodePath("NodeInputAnchor"), NodePath("NodeDataOutput"), NodePath("Label"), NodePath("PopupMenu"), NodePath("ExecutionStepDisplayIcon"), -96.0, -64.0, 96.0, 64.0, Color(0.513726, 1, 0.741176, 1), 1, Vector2(9.53674e-06, -52), Vector2(0.253968, 0.315789), ExtResource("13_8taiv"), Vector2(-0.83898, 12), Vector2(0.256188, 0.220339), ExtResource("14_nfxda"), -96.0, -64.0, 96.0, -38.0, "Node name here", SubResource("LabelSettings_qu6ij"), 1, false, ExtResource("15_lonmn"), Vector2(-104, -16), SubResource("PackedScene_kk38h"), false, Vector2(112, 8), false, false, Color(0.262745, 0.4, 1, 1), Vector2(0, -88), 1.57079, ExtResource("10_0vy0f"), 1, "Delete", 0],
"version": 3
}

[sub_resource type="CSharpScript" id="CSharpScript_go8gb"]
script/source = "using Godot;
using System.Collections.Generic;
using System.Linq;


/// <summary>
/// A special execution node that does not need a FunctionInfo to be created and instead uses type of the variable
/// </summary>
public partial class GetterNode : VariableNode
{
    protected override FunctionInfo? GetFunctionInfo(VariableInfo val)
    {
        return new FunctionInfo
        (
            \"Get\",
            false,
            new(),
            \"VisLang.VariableGetNode\",
            true,
            val.ValueType,
            true,
            val.ArrayDataType != null,
            val.ArrayDataType ?? VisLang.ValueType.Bool
        );
    }

    protected override void ApplyAdditionalDataToNode<NodeType>(NodeType node)
    {
        base.ApplyAdditionalDataToNode(node);
        if (node is VisLang.VariableGetNode get)
        {
            get.Name = Info.Name;
        }
    }
}"

[sub_resource type="LabelSettings" id="LabelSettings_eroib"]
font_color = Color(0, 0, 0, 1)

[sub_resource type="PackedScene" id="PackedScene_v15kr"]
_bundled = {
"base_scene": 0,
"conn_count": 0,
"conns": PackedInt32Array(),
"editable_instances": [],
"names": PackedStringArray("VisNode", "script", "VariableNameLabel", "Label", "offset_left", "offset_right", "text", "NodeDataOutput", "visible", "OptionButton", "OptionButton", "visible", "offset_left", "offset_top", "offset_right", "offset_bottom", "VariableNameLabel", "Label", "offset_left", "offset_top", "offset_right", "offset_bottom", "text", "label_settings", "horizontal_alignment"),
"node_count": 5,
"node_paths": [NodePath("."), NodePath("."), NodePath("."), NodePath(".")],
"nodes": PackedInt32Array(-1, -1, 2147483647, 0, -1, 2, 1, 1, 1073741826, 2, 0, 1073741824, -1, 2147483647, 1048579, -1, 3, 4, 3, 5, 4, 6, 5, 0, 1073741825, -1, 2147483647, 1835015, -1, 1, 8, 6, 0, 1073741826, 0, 10, 2097161, -1, 5, 11, 7, 12, 8, 13, 9, 14, 10, 15, 11, 0, 1073741827, 0, 17, 2359312, -1, 7, 18, 12, 19, 13, 20, 14, 21, 15, 22, 16, 23, 17, 24, 18, 0),
"variants": [SubResource("PackedScene_agsmv"), SubResource("CSharpScript_go8gb"), NodePath("VariableNameLabel"), -176.0, 16.0, "Get", true, false, -64.0, -64.0, 88.0, -36.0, -64.0, -64.0, 88.0, -38.0, "VariableName", SubResource("LabelSettings_eroib"), 2],
"version": 3
}

[sub_resource type="CSharpScript" id="CSharpScript_3k7mf"]
script/source = "using Godot;
using System;

public partial class ExecInput : Node2D
{

    public delegate void SelectedEventHandler(ExecInput sender);
    /// <summary>
    /// Called when player selects this connector via ui
    /// </summary>
    public event SelectedEventHandler? Selected;

    [Export]
    public bool IsInput { get; set; } = false;

    public ExecInput? Connection { get; set; } = null;
    public EditorVisNode? OwningNode { get; set; } = null;

    public bool IsExecConnected => Connection != null;

    private void ConnectorSelected()
    {
        // because it would be very annoying to deal with node connections from inside the node itself
        // we instead just send an event to who ever listens and hope it will start/finish connections
        Selected?.Invoke(this);
    }

    public bool CanConnect(ExecInput other)
    {
        return !(Connection != null || other.OwningNode == OwningNode || other.IsInput == IsInput);
    }
}
"

[sub_resource type="PackedScene" id="PackedScene_p1k43"]
_bundled = {
"conn_count": 1,
"conns": PackedInt32Array(1073741827, 1073741826, 15, 14, 2, 0, 0),
"editable_instances": [],
"names": PackedStringArray("NodeInput", "Node2D", "script", "Icon", "Sprite2D", "modulate", "scale", "texture", "Button", "Button", "offset_left", "offset_top", "offset_right", "offset_bottom", "ConnectorSelected", "pressed"),
"node_count": 3,
"node_paths": [NodePath("."), NodePath("."), NodePath("."), NodePath("Button")],
"nodes": PackedInt32Array(-1, -1, 1, 0, -1, 1, 2, 0, 0, 1073741824, 0, 4, 3, -1, 3, 5, 1, 6, 2, 7, 3, 0, 1073741825, 0, 9, 8, -1, 4, 10, 4, 11, 5, 12, 6, 13, 7, 0),
"variants": [SubResource("CSharpScript_3k7mf"), Color(0, 1, 0.631373, 1), Vector2(0.1875, 0.1875), ExtResource("15_lonmn"), -16.0, -16.0, 16.0, 16.0],
"version": 3
}

[sub_resource type="LabelSettings" id="LabelSettings_jybab"]
font_color = Color(0, 0, 0, 1)

[sub_resource type="PackedScene" id="PackedScene_ycuox"]
_bundled = {
"base_scene": 0,
"conn_count": 0,
"conns": PackedInt32Array(),
"editable_instances": [],
"names": PackedStringArray("VisNodeExectuable", "InputExecNode", "OutputExecNode", "NodeBasicStyleExec", "modulate", "position", "NodeBasicStyleExecBase", "position", "scale", "Label", "offset_top", "offset_bottom", "NodeOutput", "position", "NodeInput", "position", "IsInput", "Label2", "Label", "offset_left", "offset_top", "offset_right", "offset_bottom", "text", "label_settings", "Label3", "Label", "offset_left", "offset_top", "offset_right", "offset_bottom", "text", "label_settings"),
"node_count": 8,
"node_paths": [NodePath("."), NodePath("."), NodePath("."), NodePath("."), NodePath("."), NodePath("."), NodePath(".")],
"nodes": PackedInt32Array(-1, -1, 2147483647, 0, -1, 2, 1073741825, 1, 1073741826, 2, 0, 1073741824, -1, 2147483647, 524291, -1, 2, 4, 3, 5, 4, 0, 1073741825, -1, 2147483647, 786438, -1, 2, 7, 5, 8, 6, 0, 1073741826, -1, 2147483647, 1048585, -1, 2, 10, 7, 11, 8, 0, 1073741827, 0, 2147483647, 1310732, 9, 1, 13, 10, 0, 1073741828, 0, 2147483647, 1572878, 11, 2, 15, 12, 16, 13, 0, 1073741829, 0, 18, 2359313, -1, 6, 19, 14, 20, 15, 21, 16, 22, 17, 23, 18, 24, 19, 0, 1073741830, 0, 26, 2621465, -1, 6, 27, 20, 28, 21, 29, 22, 30, 23, 31, 24, 32, 25, 0),
"variants": [SubResource("PackedScene_agsmv"), NodePath("NodeInput"), NodePath("NodeOutput"), Color(1, 0.835294, 0.827451, 1), Vector2(7.62939e-06, -84), Vector2(-0.83898, -4), Vector2(0.256188, 0.288136), -96.0, -70.0, SubResource("PackedScene_p1k43"), Vector2(104, -56), SubResource("PackedScene_p1k43"), Vector2(-112, -56), true, -88.0, -64.0, -48.0, -38.0, "Exec", SubResource("LabelSettings_jybab"), 48.0, -64.0, 88.0, -38.0, "Exec", SubResource("LabelSettings_jybab")],
"version": 3
}

[sub_resource type="CSharpScript" id="CSharpScript_lwt0d"]
script/source = "using Godot;
using System.Collections.Generic;
using System.Linq;


/// <summary>
/// A special execution node that does not need a FunctionInfo to be created and instead uses type of the variable
/// </summary>
public partial class SetterNode : VariableNode
{
    protected override FunctionInfo? GetFunctionInfo(VariableInfo val)
    {
        return new FunctionInfo(\"Set\", true, new Godot.Collections.Array<FunctionInputInfo>()
        {
             new FunctionInputInfo(\"Value\", val.ValueType, val.ArrayDataType)
        }, \"VisLang.VariableSetNode\", false);
    }

    protected override void ApplyAdditionalDataToNode<NodeType>(NodeType node)
    {
        base.ApplyAdditionalDataToNode(node);
        if (node is VisLang.VariableSetNode set)
        {
            set.Name = Info.Name;
        }
    }
}"

[sub_resource type="LabelSettings" id="LabelSettings_l0e78"]
font_color = Color(0, 0, 0, 1)

[sub_resource type="PackedScene" id="PackedScene_0jmmy"]
_bundled = {
"base_scene": 0,
"conn_count": 0,
"conns": PackedInt32Array(),
"editable_instances": [],
"names": PackedStringArray("VisNodeSetter", "script", "VariableNameLabel", "CodeTheme", "NodeBasicStyleExec", "modulate", "Label", "offset_left", "offset_right", "text", "OptionButton", "OptionButton", "visible", "offset_left", "offset_top", "offset_right", "offset_bottom", "NodeInputAnchor", "position", "VariableNameLabel", "Label", "offset_left", "offset_top", "offset_right", "offset_bottom", "text", "label_settings", "horizontal_alignment"),
"node_count": 6,
"node_paths": [NodePath("."), NodePath("."), NodePath("."), NodePath("."), NodePath(".")],
"nodes": PackedInt32Array(-1, -1, 2147483647, 0, -1, 3, 1, 1, 1073741826, 2, 3, 3, 0, 1073741824, -1, 2147483647, 524292, -1, 1, 5, 4, 0, 1073741825, -1, 2147483647, 1048582, -1, 3, 7, 5, 8, 6, 9, 7, 0, 1073741826, 0, 11, 1572874, -1, 5, 12, 8, 13, 9, 14, 10, 15, 11, 16, 12, 0, 1073741827, -1, 2147483647, 2359313, -1, 1, 18, 13, 0, 1073741828, 0, 20, 3407891, -1, 7, 21, 14, 22, 15, 23, 16, 24, 17, 25, 18, 26, 19, 27, 20, 0),
"variants": [SubResource("PackedScene_ycuox"), SubResource("CSharpScript_lwt0d"), NodePath("VariableNameLabel"), null, Color(1, 1, 1, 1), -144.0, -14.0, "Set", false, -56.0, -96.0, 96.0, -68.0, Vector2(-104, -24), -64.0, -96.0, 88.0, -70.0, "VariableName", SubResource("LabelSettings_l0e78"), 2],
"version": 3
}

[node name="Functions" type="Node"]
script = ExtResource("1_0ioe4")
Functions = [ExtResource("2_wet2g"), ExtResource("3_grib6"), ExtResource("4_mdhqx"), ExtResource("5_0kae3"), ExtResource("6_d6cee")]
GetterPrefab = SubResource("PackedScene_v15kr")
SetterPrefab = SubResource("PackedScene_0jmmy")
